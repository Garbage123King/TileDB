<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.251">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>fsm2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { color: #008000; } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { color: #008000; font-weight: bold; } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>


<script src="../../../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../../../">
<link href="../../../../../images/favicon.ico" rel="icon">
<script src="../../../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>


<link rel="stylesheet" href="../../../../../quarto-materials/tiledb.css">
</head>

<body class="nav-sidebar floating nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a href="../../../../../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../../../../../quarto-materials/tiledb-logo.png" alt="" class="navbar-logo">
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="https://tiledb.com">Home page</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://tiledb.com/contact">Contact us</a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/TileDB-Inc/TileDB">Repo</a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
    <div class="container-fluid d-flex justify-content-between">
      <h1 class="quarto-secondary-nav-title">(Untitled)</h1>
      <button type="button" class="quarto-btn-toggle btn" aria-label="Show secondary navigation">
        <i class="bi bi-chevron-right"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../index.html" class="sidebar-item-text sidebar-link">Public code docs</a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="../../../../../format_spec/FORMAT_SPEC.html" class="sidebar-item-text sidebar-link">Format Specification</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">Array</a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="false">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../format_spec/array_file_hierarchy.html" class="sidebar-item-text sidebar-link">Array File Hierarchy</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../format_spec/array_schema.html" class="sidebar-item-text sidebar-link">Array Schema</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../format_spec/fragment.html" class="sidebar-item-text sidebar-link">Fragment</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../format_spec/tile.html" class="sidebar-item-text sidebar-link">Tile</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../format_spec/generic_tile.html" class="sidebar-item-text sidebar-link">Generic Tile</a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">Group</a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" aria-expanded="false">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../format_spec/group_file_hierarchy.html" class="sidebar-item-text sidebar-link">Group File Hierarchy</a>
  </div>
</li>
      </ul>
  </li>
          <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">Other</a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" aria-expanded="false">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth2 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../format_spec/consolidated_fragment_metadata_file.html" class="sidebar-item-text sidebar-link">Consolidated Fragment Metadata File</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../format_spec/filter_pipeline.html" class="sidebar-item-text sidebar-link">Filter Pipeline</a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../format_spec/vacuum_file.html" class="sidebar-item-text sidebar-link">Vacuum File</a>
  </div>
</li>
      </ul>
  </li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">Developer Docs</a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" aria-expanded="true">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../../../../../doc/dev/style/index.html" class="sidebar-item-text sidebar-link">Style Guide</a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">



<p>The file fsm.h implements a state machine for two communicating ports, <code>Source</code> and <code>Sink</code>. Each port has two states, empty or full. There are two transition events associated with the source: fill, which transitions from empty to full and tells the state machine there is an item in the <code>Source</code>, and and push, which initiates transfer to the <code>Sink</code> and transitions from full to empty.</p>
<p>Similarly, there are two events associated with the sink: drain, which transitions from full to empty and tells the <code>Sink</code> node that its item has been removed, and and pull, which attempts to transfer an item from the <code>Source</code> and transitions from empty to full. For simplicity, though we may need them in the future, there are currently no defined events for startup, stop, forced shutdown, or abort.</p>
<p>To complete the functionality of the state machine for the purposes of safely transferring data from a <code>Source</code> to a <code>Sink</code>, there are exit and entry actions associated with selected states and events.</p>
<p>The following diagrams show the entry and exit actions for each state machine, for the <code>Source</code> and <code>Sink</code> in isolation. Note that there is some “spooky action at a distance” between the two due to waiting in one with notification from the other. We don’t show those interactions in the diagram, but capture than in the state transition and event action tables.</p>
<p><img source="source_state_machine.svg" width="360"> <img source="sink_state_machine.svg" width="360"></p>
<p>We can combine the source and sink state machines into a single “product” state machine wherein the overall state is represented with two bits, one for the source and one for the sink, e.g., “00” meaning that the source state is 0 and the sink state is 1. The following diagram shows the state transitions for the product state machine.</p>
<p><img source="two_stage.svg" width="720"></p>
<p>One particular aspect of this is the pull event from state 00 and the push event from state 11. In these cases, the exit action is “wait”, since the only valid state to complete a push or a pull is from state 01. Accordingly, we perform notifications as entry actions to state 10.</p>
<p>When a source or sink thread is released from its wait, it is still in the push or pull event. To enable it to complete that desired operation, we restart the event processing for the push or pull event in the current state.</p>
<p>(As a slight optimization, we also perform notifications on entry to states 00 and 11. The waiter doesn’t get to move in that case, but does get to leave the wait and produce or consume an item and then try to push or pull again.)</p>
<p>Our basic goal for the <code>Source</code> and <code>Sink</code> ports is to transfer a data item from a <code>Source</code> to a connected (bound) <code>Sink</code>. At a high level, the way a client would use the <code>Source</code> to do this is the following: - create a data item - insert the data item into a <code>Source</code> port - invoke the fill event - invoke the push event</p>
<p>Similarly, the desired usage of a <code>Sink</code> port is also to transfer a data item from a <code>Source</code> to a bound <code>Sink</code>. At a high level, the way a client would use the <code>Source</code> is the following - invoke the pull event - extract the data item from the <code>Sink</code> port - consume the item - invoke the drain event</p>
<p>Based on these product states and the four above events, the state transition table for the product state machine (which we will just refer to as the “state machine” below is the following:</p>
<table class="table">
<colgroup>
<col style="width: 11%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th></th>
<th></th>
<th></th>
<th>Event</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>State</td>
<td>fill</td>
<td>push</td>
<td>drain</td>
<td>pull</td>
<td>stop</td>
</tr>
<tr class="even">
<td>00</td>
<td>10</td>
<td>00</td>
<td></td>
<td>01</td>
<td></td>
</tr>
<tr class="odd">
<td>01</td>
<td>11</td>
<td>01</td>
<td>00</td>
<td>01</td>
<td></td>
</tr>
<tr class="even">
<td>10</td>
<td></td>
<td>01</td>
<td></td>
<td>01</td>
<td></td>
</tr>
<tr class="odd">
<td>11</td>
<td></td>
<td>01</td>
<td>10</td>
<td>11</td>
<td></td>
</tr>
</tbody>
</table>
<p>Using this table, we can include the states as predicates with “proof outline” statements for the <code>Source</code> operation:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> produce and insert item</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = full } */</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> fill</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∨ state = 11 } ∧ { source_item = full } */</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> push</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Similarly for <code>Sink</code>:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>   <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 10 } ∧ { sink_item = empty } */</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> pull</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∨ state = 11 } ∧ { sink_item = full } */</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> extract and consume item  </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∨ state = 11 } ∧ { sink_item = full } */</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>     <span class="cf">do</span> drain</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 10 } ∧ { sink_item = empty } */</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>   <span class="op">}</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Now, the <code>Source</code> and <code>Sink</code> need to coordinate <code>push</code> and <code>pull</code> so there is not a race condition (nor a deadlock) when making transitions in the state machine. Moreover, we have to make sensible transitions. That is, we only be able to succesfully do a push when the <code>Sink</code> state is empty (and the <code>Sink</code> item itself is empty). This is why we insert a new item and <em>then</em> invoke fill. Until the state has transitioned to indicate the state of the <code>Source</code> is full, the <code>Sink</code> will not attempt to transfer the item. Similarly, we empty the sink_item and <em>then</em> signal that the <code>Sink</code> is in the empty state.</p>
<p>To do this, we associate exit and entry actions with each state transition, some of which will synchronize between <code>Source</code> and <code>Sink</code>. These actions are used with the state transition thusly:</p>
<ul>
<li>begin_transition: given old_state and event</li>
<li>execute exit(old_state, event)</li>
<li>new_state = transition(old_state, event)</li>
<li>execute entry(new_state, event)</li>
</ul>
<p>Note that the exit action is called <em>before</em> the state transition. Note also that the entry action is called with the new state (the post transition state).</p>
<p>The tables for exit actions to be perfomed on state transitions is:</p>
<table class="table">
<colgroup>
<col style="width: 11%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th></th>
<th></th>
<th></th>
<th>Events</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>State</td>
<td>fill</td>
<td>push</td>
<td>drain</td>
<td>pull</td>
<td>stop</td>
</tr>
<tr class="even">
<td>00</td>
<td></td>
<td>return</td>
<td></td>
<td>sink_wait</td>
<td></td>
</tr>
<tr class="odd">
<td>01</td>
<td></td>
<td>return</td>
<td></td>
<td>return</td>
<td></td>
</tr>
<tr class="even">
<td>10</td>
<td></td>
<td>source_swap</td>
<td></td>
<td>sink_swap</td>
<td></td>
</tr>
<tr class="odd">
<td>11</td>
<td></td>
<td>source_wait</td>
<td></td>
<td>return</td>
<td></td>
</tr>
</tbody>
</table>
<p>The table for entry actions to be performend on state transitions is:</p>
<table class="table">
<colgroup>
<col style="width: 11%">
<col style="width: 18%">
<col style="width: 18%">
<col style="width: 20%">
<col style="width: 18%">
<col style="width: 13%">
</colgroup>
<thead>
<tr class="header">
<th></th>
<th></th>
<th></th>
<th></th>
<th>Events</th>
<th></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>State</td>
<td>fill</td>
<td>push</td>
<td>drain</td>
<td>pull</td>
<td>shutdown</td>
</tr>
<tr class="even">
<td>00</td>
<td></td>
<td></td>
<td>notify_source</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>01</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>10</td>
<td>notify_sink</td>
<td></td>
<td>notify_source</td>
<td></td>
<td></td>
</tr>
<tr class="odd">
<td>11</td>
<td>notify_sink</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>The <code>source_swap</code> function is used to potentially transfer the data items associated with <code>Source</code> and <code>Sink</code> from the <code>Source</code> to the <code>Sink</code> (as well as changing the state if data transfer is carried out). The <code>source_swap</code> function is invoked whenever the state is 10 (which is when there is an item in <code>Source</code> and space available to transfer to the <code>Sink</code>. The data transfer is carried out by swapping the <code>Source</code> and <code>Sink</code> items and changing the state of 10 to 01.</p>
<p>When the state is 00, the <code>Sink</code> will wait for the <code>Source</code> to become full. The <code>Source</code> will notify the <code>Sink</code> when it becomes full. Similarly, if the state is 11, the <code>Source</code> will wait until it is signalled by the <code>Sink</code> that the <code>Sink</code> is empty.</p>
<p>In more detail, we can describe the <code>Source</code> behavior (including proof outline predicates). The steps of <code>Source</code> operation are pseudocode in normal text, while the associated state of the state machine are given in comments, with predicates in curly braces.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>  init<span class="op">:</span> <span class="co">/* { state = 00 ∧ source_item = empty } */</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>     client of the source inserts an item  <span class="co">/* Note that although the Sink can execute and potentially change the</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co">                                              state here, the allowable transitions do not end up changing it */</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = full } */</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>     client invokes fill event to transition from empty to full<span class="op">.</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>     state machine locks mutex</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { mutex = locked } */</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>     state machine invokes exit action</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> ∨ state <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> → none</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = full } */</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>     state machine performs transition</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 } → { state = 10 } ∧ { source_item = full } */</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 } → { state = 11 } ∧ { source_item = full } */</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∨ state = 11 } ∧ { source_item = full } */</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>     Source notifies Sink that it is full</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∨ state = 11 } ∧ { source_item = full } */</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>     Source returns</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>     state machine unlocks mutex</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { mutex = unlocked } */</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* Before the Source begins the push, the Sink may pull, drain, do both, or do nothing */</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∨ state = 11 ∨ state = 01 ∨ state = 00 } ∧ { source_item = empty ∨ source_item = full } */</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>     client invokes push event</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>     state machine locks the mutex</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { mutex = locked */</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 10 ∨ state = 11 ∨ state = 01 ∨ state = 00 } ∧ { source_item = empty ∨ source_item = full } */</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>     state machine executes push exit action<span class="op">,</span> which may be one of the following<span class="op">,</span> depending on the state</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>     restart<span class="op">:</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> ∨ state <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> → none</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> state <span class="op">=</span> <span class="dv">10</span> → execute source_swap</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> state <span class="op">=</span> <span class="dv">11</span> → execute source_wait</span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>         pre_source_swap<span class="op">:</span> <span class="co">/* { state = 10 } ∧ { source_item = full } */</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>            state machine swaps source_item and sink_item <span class="op">--</span> swap does not change state</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>         post_source_swap<span class="op">:</span> <span class="co">/* { state = 10 } ∧ { source_item = empty } */</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> → execute source_wait  </span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>          pre_source_wait<span class="op">:</span> <span class="co">/* { state = 11 } */</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>          <span class="co">/* unlock mutex and wait for Sink to become empty */</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>          <span class="co">/* Important! When the state machine comes back from wait, it is now no longer in the state it was when it started the wait. */</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>          <span class="co">/* We therefore restart event processing for the push event, given the state present when coming back from wait: goto restart.*/</span></span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { mutex = locked } */</span></span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { state = 00 ∨ state = 01 ∨ state = 10 } ∧ { source_item = empty } */</span>      </span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>       make state transition according to state transition table and next_state set by most recent event</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span></span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>       state machine invokes entry action <span class="op">(</span>none<span class="op">)</span> </span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>       post_entry<span class="op">:</span> <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>       state machine unlocks mutex</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { mutex = unlocked } */</span></span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>      post_push<span class="op">:</span> <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>    end_loop<span class="op">:</span> <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span>
<span id="cb3-64"><a href="#cb3-64" aria-hidden="true" tabindex="-1"></a>  post_loop<span class="op">:</span> <span class="co">/* { state = 00 ∨ state = 01 } ∧ { source_item = empty } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>The <code>Sink</code> is the dual of the Source. Note that we start with pull. We can describe the <code>Sink</code> behavior (including proof outline predicates):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode c code-with-copy"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>  init<span class="op">:</span> <span class="co">/* { state = 00 ∧ sink_item = empty } */</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">while</span> <span class="op">(</span>not done<span class="op">)</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 } ∧ { sink_item = empty ∨ sink_item = full } */</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* Before client invokes the pull event, the source could have filled, filled and pushed, or done nothing */</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> source filled<span class="op">:</span> <span class="bn">00</span> → <span class="dv">10</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> source filled and pushed <span class="bn">00</span> → <span class="bn">01</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> source filled and pushed and filled <span class="bn">00</span> → <span class="dv">11</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>       <span class="cf">if</span> source did nothing state does not change</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 ∨ state = 10 ∨ state = 10 } ∧ { sink_item = empty ∨ sink_item = full } */</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>     client invokes pull event</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>     state machine locks mutex</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* mutex = locked */</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 01 ∨ state = 10 ∨ state = 11 } ∧ { sink_item = empty ∨ sink_item = full } */</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>     state machine executes pull exit action<span class="op">,</span> which may be one of the following<span class="op">,</span> depending on the state</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>     restart<span class="op">:</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>       <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> → none</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>       <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → sink_swap </span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>       <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> → sink_wait</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>         pre_sink_swap<span class="op">:</span> <span class="co">/* { state = 10 } ∧ { sink_item = empty } */</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>         post_sink_swap<span class="op">:</span> <span class="co">/* { state = 10 } ∧ { sink_item = full } */</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>         <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> → execute sink_wait</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>         pre_sink_wait<span class="op">:</span> <span class="co">/* { state = 00 } */</span> </span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>           <span class="co">/* unlock mutex and wait for Source to become full */</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>           <span class="co">/* Important! When the state machine comes back from wait, it is now no longer in the state it was when it started the wait. */</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>           <span class="co">/* We therefore restart event processing for the pull event, given the state present when coming back from wait: goto restart.*/</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { mutex = locked */</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { state = 01 ∨ state = 10 ∨ state = 11 } ∧ { sink_item = full } */</span>      </span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>       make state transition according to state transition table and state and next_state set by most recent event</span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>         <span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* { state = 01 ∨ state = 11 } ∧ { sink_item = full } */</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>       state machine invokes pull entry action <span class="op">(</span>none<span class="op">)</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>       <span class="co">/* post_entry: { state = 01 ∨ state = 11 } ∧ { sink_item = full } */</span> </span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>     state machine unlocks mutex</span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { mutex = unlocked */</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* post_pull: { state = 01 ∨ state = 11 } ∧ { sink_item = full } */</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>     client of the sink extracts the item  <span class="co">/* Note that although the Source can execute and potentially change the</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="co">                                                state here, the allowable transitions do not end up changing it */</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∨ state = 11 } ∧ { sink_item = empty } */</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>     client invokes drain event to transition from full to empty </span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>     state machine locks mutex</span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 01 ∨ state = 11 } ∧ { sink_item = empty } */</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>     state machine performs exit action</span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>     <span class="cf">if</span> <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> → none</span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> ∨ state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>     state machine performs transition</span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> state <span class="op">=</span> <span class="bn">01</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>     <span class="op">{</span> state <span class="op">=</span> <span class="dv">11</span> <span class="op">}</span> → <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* { state = 00 ∨ state = 10 } ∧ { sink_item = empty } */</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a>     state machine performs entry action</span>
<span id="cb4-57"><a href="#cb4-57" aria-hidden="true" tabindex="-1"></a>       <span class="op">{</span> state <span class="op">=</span> <span class="bn">00</span> <span class="op">}</span> → notify_source</span>
<span id="cb4-58"><a href="#cb4-58" aria-hidden="true" tabindex="-1"></a>       <span class="op">{</span> state <span class="op">=</span> <span class="dv">10</span> <span class="op">}</span> → notify_source</span>
<span id="cb4-59"><a href="#cb4-59" aria-hidden="true" tabindex="-1"></a>     Sink returns</span>
<span id="cb4-60"><a href="#cb4-60" aria-hidden="true" tabindex="-1"></a>     state machine unlocks mutex</span>
<span id="cb4-61"><a href="#cb4-61" aria-hidden="true" tabindex="-1"></a>     <span class="co">/* end_loop: { state = 00 ∨ state = 10 } ∧ { sink_item = empty } */</span></span>
<span id="cb4-62"><a href="#cb4-62" aria-hidden="true" tabindex="-1"></a>  <span class="co">/* post_loop: { state = 00 ∨ state = 10 } ∧ { sink_item = empty } */</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Operations carried out directly by the state machine are protected by a lock. When the <code>Source</code> or <code>Sink</code> wait, they do so on a condition variable using that same lock.</p>
<p>Note that when the <code>Source</code> and <code>Sink</code> both exit their loops that the <code>Source</code> will have { state = 00 ∨ state = 01 } while the <code>Sink</code> will have { state = 00 ∨ state = 10 }. The final state of the state machine is therefore { state = 00 ∨ state = 01 } ∧ { state = 00 ∨ state = 10 } ∧ { item = empty }, i.e., { state = 00 } ∧ { item = empty }. (This assumes that both <code>Source</code> and <code>Sink</code> perform the same number of operations, otherwise one of them will be left in a wait.)</p>
<p><strong>NB:</strong> The sink_swap and source_swap functions are identical. Each checks to see if the state is equal to 10, if so, swap the state to 01 (and perform an action swap of the items assoiated with the source and sink), and notifies the other. If the state is not equal to 10, the swap function notifies the other and goes into a wait.</p>
<p>Thus, we may not need separate swaps for <code>Source</code> and <code>Sink</code>, nor separate condition variables, nor separate notification functions. I have verified that this works experimentally, but I am leaving things separate for now.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>